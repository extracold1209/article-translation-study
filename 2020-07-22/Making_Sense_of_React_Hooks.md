> 제목 : Making Sense of React Hooks (React Hooks 이해하기)
> 글쓴이 : Dan Abramov
> 출처 : https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889

> 요약

>
> 페이스북은 리액트 hooks 를 선호한다. 그 이유는 아래와 같다.
> 기존의 클래스 컴포넌트가 프로젝트가 커지면서 비대해지고,  
> 라이프사이클 단위로 쪼개지기 때문에 중복된 로직이 생길 수 있고,  
> render props 체인과 HOC 로 인한 패턴의 복잡화를 꼽았다.   

> hooks 는 로직의 관심사를 한 군데에 몰아둘 수 있고, 함수 단위이기 때문에 custom hooks 와 같은 결합이나 로직의 분리, 재활용이 쉽다.    
> 본문 내용중에서는 아래와 같이 hooks 의 장점을 설명한다.  
> 'hooks 는 class 로서 할수있는 모든 use-case 를 커버할 수 있으며 나아가 추출, 테스트, 코드재사용에 있어 더욱 유연함을 제공한다.  
> 이것이 hooks 가 리액트의 미래라고 말하는 우리들의 비전인 이유이다.'

---

이번주, Sophie Alpert 와 나는 React conf 에서 hooks 제안을 발표하였고, 이어 Ryan Florence 심층연설이 이어졌다.
나는 이 hooks 를 통해 해결하고자 하는 문제를 알기 위해 위 기조연설 영상을 보기를 추천한다.
그러나, 한 시간이라는 것은 큰 투자입니다. 그렇기 때문에 나는 아래에 몇가지 hooks 에 대한 생각을 공유하기로 결정했
다.
> 노트: hooks 는 리액트의 실험적 제안이다. 당신은 지금당장 이것들을 알아야할 필요는 없다.
> 또한, 이 포스트는 내 개인적인 의견을 포함하고 있고 이것이 리액트 팀의 입장을 반드시 반영하는 것은 아니다.

# 왜 hooks 인가?
우린 컴포넌트들과 top-down 방식의 데이터플로우가 작고, 독립적이고, 재사용 가능한 조각들로 거대한 UI 를 구성하
는데 도움을 준다는 것을 알고 있다.

그러나, 로직이 상태적이고 함수나 다른 컴포넌트로 추출될 수 없기 때문에, 우린 복잡한 컴포넌트를 더이상 쪼갤 수 없
는 경우가 종종 있다.

때때로 이런 경우가 사람들이 '리액트는 분리된 관심사 주지 않는다' 라고 말할때의 의미이다.

이런 경우는 애니메이션을 포함하거나, form 을 조작하는 경우, 외부 소스와 연결하는 등 우리가 컴포넌트를 가지고 하
는 다양한 일들에서 굉장히 보편적으로 일어난다. 우리가 컴포넌트만으로 이런 문제를 해결하고자 할때, 우린 보통 아래
와 같은 방식으로 끝나곤 한다.

- 리팩토링과 테스트하기 어려운 '거대 컴포넌트들'
- 라이프사이클 메소드와 다른 컴포넌트들 사이에 있는 '중복된 로직'
- Render props 와 HOC(High Order Components) 와 같은 복잡한 패턴

우린 hooks 가 위의 모든 문제를 해결해줄 좋은 해결책이라고 생각한다. hooks 는 우리를 컴포넌트 내부의 로직을 재사
용가능한 독립 단위로 구성할 수 있도록 해줄 것이다.

![image](https://pbs.twimg.com/media/DqnGs6yWwAAYPXp?format=jpg&name=small)
![image2](https://pbs.twimg.com/media/DqnGuEnWsAAt1Xt?format=jpg&name=small)

hooks 는 컴포넌트들 사이가 아닌, 컴포넌트 내부에 리액트의 철학 (명시적인 데이터흐름과 구성)을 적용한다.
이것이 내가 hooks 가 리액트 컴포넌트 모델에 더 자연스럽게 맞아떨어진다고 느끼는 이유이다.

render props 나 HOC 같은 패턴과는 다르게, hooks 는 당신의 컴포넌트 트리에 불필요하게 중첩되지 않도록 설명한다.
hooks 는 또한 믹스인의 단점에서 오는 고통에서 벗어날 수 있게 해준다.

당신이 이에 대해 거부반응이 들더라도 (물론 나도 처음에 그랬다), 내가 당신에게 이 제안에 대한 공정한 시도와 이를 즐
길 수 있도록 격려해주도록 하겠다. 내 생각엔 당신도 맘에 들 것이다.

# hooks 가 리액트를 비대하게 만드는건 아닌가?

우리가 hooks 를 면밀히 보기 전, 당신은 우리가 단순히 리액트에 hooks 라는 컨셉을 추가한 것 뿐이 아니냐는 걱정을
할 수 있다. 그것은 합당한 비판이다. 난 이것들을 배우는데 단기적인 학습비용이 있을 것이지만, 최종적으론 정반대의
결과가 될 것이라고 생각한다.

만약 리액트 커뮤니티가 hooks 제안을 수용하게 되면, 이것은 리액트 어플리케이션을 작성할때 당신이 필요한 개념의
수를 줄일 수 있게 될 것이다. hooks 는 당신이 지속적으로 함수, 클래스, HOC, render props 를 계속 번갈아 사용하는
것 대신, 오로지 함수만을 사용할 수 있게 만들어 줄 것이다.

사이즈에 대한 부분에서, hooks 를 지원하는데 있어 리액트는 겨우 ~1.5kb 정도 상승했다. 그다지 많은 편은 아니지만,
hooks 를 사용하면 클래스 기반 코드보다 더 잘 축소되기 때문에 번들 크기는 줄어들 수 있다. 아래의 예시는 조금 극단
적이긴 하지만 왜 번들크기가 줄어들 수 있는지를 효과적으로 보여준다.

(예시가 없음;)

hooks 제안은 어떤 변경사항도 포함하지 않는다. 당신의 기존 코드는 개발하던 그대로 둘 수 있으며 거기에 신규 컴포넌
트에만 hooks 를 적용할 수 있다. 사실, 이게 우리가 정확히 추천하는 방법 - 전부 재작성하거나 하지 말아라! - 이다. 이
방법은 어떤 크리티컬한 코드가 hooks 가 적용되는데 기다릴 수 있는 좋은 아이디어이다.

그래도 hooks 제안과 다른 버그들에 대한 피드백을 위해 16.7 alpha 버전을 체험해보길 바란다.

# 정확히 hooks 는 무엇인가?

hooks 를 이해하기 위해, 우린 한걸음 물러나 코드 재사용성에 대해 생각해볼 필요가 있다.

오늘날, 리액트 어플리케이션 안에서는 많은 방법의 코드 재사용 방법들이 생겨났다. 우린 간단한 함수를 만들고 뭔가를
계산하기 위해 이를 호출할 수 있다. 우린 또한 컴포넌트들을 작성하고(함수가 되었던 클래스가 되었던간에). 컴포넌트들
은 좀더 강력하지만, 그들을 몇 UI 에 렌더되어야 한다. 이것들은 보이지 않는 로직을 공유하는데 있어서는 불편함을 발
생시킨다. 이것들이 왜 우리가 render props 와 HOC 로 끝나게 되곤 한다.

만약 이런 많은 코드들 대신 코드를 재사용하는 일반적인 방법이 한가지만 있다면 리액트가 좀 더 간단해지지 않을까?
함수는 코드를 재사용하는 데에는 완벽한 메커니즘으로 보인다. 함수간에 로직을 이동시키는 것은 그 노력도 덜든다.

그러나, 함수는 함수안에 리액트의 로컬 state 를 가질 수 없다. 당신은 'window 사이즈를 감지하고 state 를 업데이트
한다' 거나 '일정시간 동안 animate' 와 같은 행동을 당신의 코드를 재구성하거나 observables 같은 추상화를 통하지 않
고서는 클래스 컴포넌트에서 추출해낼 수가 없다. 위 두 접근법은 리액트의 단순성을 손상시킨다.

hooks 는 정확히 이와 같은 문제를 해결한다. hooks 는 리액트의 feature 단일 함수를 호출하는 것만으로 사용
할 수 있게 해준다.(state 같은 기능들) 리액트는 state, lifecycle, context 와 같이 노출된 '빌딩 블록들' 몇가지
를 빌트인으로 제공한다.

hooks 는 일반적인 js 함수이므로, 당신은 리액트가 제공하는 빌트인 hooks 와 당신만의 'custom hooks' 를
결합할 수 있다. 이를 통해 복잡한 문제를 한줄로 해결하고, 당신의 어플리케이션이나 리액트 커뮤니티에도 공
유할 수 있다.

custom hooks 에 대한 노트는 기술적인 react feature 가 아니다. custom hooks 를 작성할 가능성은 hooks
가 설계된 방식에 따라 자연스럽게 흘러갈 것이다.

# 코드 좀 보여줘봐!

우리가 현재 윈도우 너비를 구독하는 컴포넌트가 필요하다고 해보자.
(예를들어, 좁은 뷰포트 위에서 다른 컨텐츠를 보여주어야 하는 경우)

당신은 몇가지 코드를 작성할 방법이 있다. 그것들은 클래스를 작성하고, 몇가지 라이프사이클 메소드를 세팅하
고, 아니면 아마 당신이 컴포넌트간 재사용을 원한다면 render prop 으로 추출하거나 HOC 를 작성할 수도 있
을 것이다. 하지만 나는 이 코드를 이길 방법은 없다고 생각한다.

![code](https://miro.medium.com/max/700/1*j8U3U0nZvmEKJrSOK7iH5g.png)

만약 당신이 이 코드를 읽는다면, 이 코드가 뭘 말하는지 정확히 알 수 있을 것이다. 우린 우리들의 컴포넌트 안
에서 window 의 너비를 사용하고, 이 너비값이 변경되면 리액트는 re-render 한다. 그리고 이게 hooks 의 목
표 - 컴포넌트가 state 와 사이드이펙트를 포함하고 있더라 하더라도 확실히 선언적으로 작성할 수 있는 것 -
이다.

한번 custom hook 은 어떻게 작성될 수 있는지 보자. 우린 react local state 를 현재의 window 너비를 가지
고 있기 위해 사용하였고, window 가 리사이즈 되면 state 를 설정하도록 사이드이펙트를 사용하였다.

![code2](https://miro.medium.com/max/700/1*9QhpwSGTKM-c8sc4UNcxqA.png)

당신이 위에서 본것처럼, useState 와 useEffect 같은 빌트인 hooks 는 기본적인 빌딩 블록으로서 제공된다.
우린 우리들의 컴포넌트들에서 이것들을 직접 사용하거나, useWindowWidth 와 같은 custom hooks 에 결합
하여 사용할 수 있다. custoom hooks 를 사용하는것은 react 의 빌트인 API 를 사용하는 것만큼 관용적이다.
당신은 이 overview(링크) 에서 더 많은 빌트인 hooks 를 학습할 수 있다.

hooks 는 완전히 캡슐화 되어있다. - 당신이 hook 을 호출할 때마다, 이는 현재 실행중인 컴포넌트에 맞춰 독
립적인 local state 를 가진다. - 위의 단편적인 예시에서 이런 면은 중요하지 않다. (모든 컴포넌트에서
window 너비값은 똑같을 테니까!), 하지만 이런 점은 hooks 를 더욱 강력하게 만든다.

이것들은 state 를 공유하는 방법이 아니다. - 오히려 stateful 한 로직을 공유하는 방법이다. 우린 top-down
방식의 데이터 플로우를 손상시키고 싶지 않다!

각 hook 들은 몇가지 local state 와 사이드이펙트를 가질 수 있다. 당신은 당신이 평소에 함수들 사이에서 그랬
던 것처럼 여러 hooks 사이에서도 데이터를 전달할 수 있다.
그들은 js 함수기 때문에 인자를 받고 값을 반환할 수 있다.

[react-spring 예제는 넘어갔음. 첨부 불가능이라]

hooks 간의 데이터를 전달할 수 있다는 기능은 애니메이션을 표현하거나, 데이터 구독, form 관리 그리고 다른
상태관리가 필요한 추상화에 잘 맞아듣는다.

render props 혹은 HOC와는 다르게, hooks 는 당신의 render tree 에 '부정계층' 을 만들지 않는다.
그들은 컴포넌트에 '메모리 세포' 와 같은 플랫리스트로서 붙게된다. 추가적인 레이어 없이 말이다.

# 그럼 class 들은 어떻게되나?

custom hooks 는, 우리들의 생각으론, hooks 제안에서 가장 어필이 되는 부분이다.
하지만 custom hooks 가 동작하기 위해서는, 리액트는 state 의 선언과 사이드이펙트를 포함한 함수를 제공할
필요가 있다.

그리고 이것들이 정확히 useState 와 useEffect 와 같은 빌트인 hooks 가 제공하는 부분이다. 당신은 이들을
documentation 안에서 배울 수 있다.

이런 빌트인 hooks 는 custom hooks 를 만드는데만 유용한 것은 아니다. 이것들은 state 와 같은 우리가 필요
한 모든 기능을 제공하기 때문에 일반적인 컴포넌트를 정의하는데에도 충분하다.
이것이 바로 우리가 미래에 hooks 가 리액트 컴포넌트를 정의하는 제일 기본적인 방법으로 정의되기를 바라는
이유이다.

우리는 class 를 deprecate 할 계획은 없다. 당신처럼 페이스북은 1만개가 넘는 클래스 컴포넌트를 가지고 있
다. 우린 이것들을 재작성할 의향이 없다. 하지만 리액트 커뮤니티가 hooks 를 포용한다면, 컴포넌트를 작성하
는데 두가지 방법이 추천되는 것은 말이 되지 않는다.

hooks 는 class 로서 할수있는 모든 use-case 를 커버할 수 있으며 나아가 추출, 테스트, 코드재사용에 있어 더
욱 유연함을 제공한다. 이것이 hooks 가 리액트의 미래라고 말하는 우리들의 비전인 이유이다.

---

(아래 # But Aren't Hooks Magic? 섹션 부터는 너무 길어서 번역 안했음 ㅈㅅ)
