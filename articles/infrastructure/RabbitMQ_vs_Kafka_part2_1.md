> 제목 : RabbitMQ vs. Kafka: Head-To-Head                                                                           
> 출처 : https://medium.com/better-programming/rabbitmq-vs-kafka-1779b5b70c4

--- 

## 서론
소프트웨어 아키텍트로 여러 마이크로서비스 기반의 시스템을 다루면서, 종종  "RabbitMQ 와 Kafka 중 무엇을 써야할까?"라는 의문을 갖곤 한다. 
많은 개발자들은 이 기술들을 서로 대체가능하다고 생각한다. 대부분의 경우엔 옳지만, 두 플랫폼 간에는 다양한 차이점이 존재한다.

결과적으로 시나리오마다 다른 솔루션이 필요하고, 잘못된 솔루션을 고른다면  소프트웨어의 설계, 개발, 그리고 유지보수에 까지 치명적인 영향을 끼칠 수 있다.

이 시리즈의 파트 1은 RabbitMQ 와 Kafka 의 내부 구현 개념에 대해 설명한다. 이번 파트에서는 두 플랫폼 사이의 주목할만한 차이점과 소프트웨어 아키텍트 및 개발자로서 주목해야 할 차이점을 계속해서 검토할 것이다.

그러고나서, 일반적으로 이러한 도구를 이용하여 구현하고자 하는 구조 패턴을 설명하고 각각 언제 사용해야 할 지를 평가할 것이다.

### Note 1
RabbitMQ 와 Kafka 의 내부 구조가 익숙하지 않다면, 먼저 이 글의 첫 번째 파트를 읽어보기를 권한다. 확실하지 않으면 헤드라인과 다이어그램을 훑어봄으로써 최소한 둘의 차이점들을 확인해볼 수 있다.

### Note 2
먼저 올린 글에 Apache Pulsar 에 대해 묻는 독자들이 있었다. Pulsar 는 RabbitMQ 와 Kafka 가 제공하는 최고의 기능을 결합을 목표로하는 또 다른 메시징 플랫폼이다.

최신 플랫폼으로써 아주 유망해보이기는 하나, 다른 어느 플랫폼처럼 강점과 약점이 존재할 것이다. 이 글은 RabbitMQ 와 Kafka 에 초점을 맞추고 있기에, 향후 다른 글을 통해 Pulsar 의 비교에 대해 설명하려 한다.

_cf. [Apache Pulsar](http://pulsar.apache.org/docs/ko/next/concepts-overview/)_

## RabbitMQ 와 Kafka 의 주목할만한 차이점
RabbitMQ 는 메시지 브로커, Kafka 는 분산 스트리밍 플랫폼이다. 이 차이는 의미론적으로 비춰질 수 있으나, 그것은 다양한 유스 케이스를 편안하게 구현할 수 있는 능력에 영향을 끼치는 심각한 암시를 수반한다.

예를 들어, Kafka는 데이터 스트림을 처리하는데 사용하기 적합하고, RabbitMQ 는 
스트림 내 메시지의 순서와 관련해 최소한의 보증을 제공한다.

다른 한편으로 RabbitMQ 는 재시도 로직과 dead-letter exchanges 에 대한 지원이 내장되어 있는 반면, Kafka 는 그러한 구현들을 사용자의 손에 맡긴다.

이번 절에서는 이러한 구분되는 플랫폼 간의 주목할만한 차이점들을 중점적으로 다룰 것이다.

### 메시지 오더링
![image](./images/message_ordering.jpg)

RabbitMQ 는 큐 혹은 교환으로 전송된 메시지의 순서에 대한 보증을 거의 제공하지 않는다. 생산자가 메시지를 보낸 순서대로 소비자가 처리하는 것이 분명해 보일 수도 있지만, 이는 오해의 소지가 있다.

RabbitMQ 문서에서는 순서 보장에 관련하여 다음과 같이 설명한다:

> "한 채널에서 하나의 교환과 하나의 큐, 하나의 송신 채널을 통과하는 메시지가 전송된 것과 같은 순서로 수신될 것이다." - [RabbitMQ Broker Semantics](https://www.rabbitmq.com/semantics.html)

달리 말하자면, 단 한명의 메시지 소비자가 있는 한 메시지를 순서대로 받겠지만, 동일한 큐에서 메시지를 읽는 소비자가 여러 명이 되면 메시지가 처리되는 순서에 대해서는 보장할 수가 없다.

이러한 순서 보장의 결함은 소비자가 메시지를 큐로부터 읽은 후 되돌릴(재전송할) 수 있기 때문에 발생한다. (예: 메시지 처리 실패)

메시지가 반환되고 나면, 다른 소비자가 그 이후의 메시지를 이미 소비했음에도 불구하고 반환된 메시지를 처리할 수 있다. 따라서, 소비자 그룹은 아래 다이어그램에서 보이는 것 처럼 잘못된 순서로 처리하게 된다.

![image](./images/lost_message_ordering.png)
*RabbitMQ 사용시 메시지 순서 손실 예*

물론 소비자 동시성을 하나로 제한함으로써 RabbitMQ 에서 메시지 순서를 다시 얻을 수 있다. 더 정확하게는 병렬 메시지 처리는 똑같이 메시지 순서 비보장 이슈를 초래할 수 있기 때문에, 단일 소비자 내 스레드 수는 한 개로 제한되어야 한다.

그러나, 단일 스레드 소비자로 제한하면 시스템이 성장함에 따라 메시지 처리에 대해 확장하는 능력에 심각한 영향을 끼칠 수 있다. 결과적으로, 이런 트레이드 오프를 속편하게 수행해서는 안된다.

반면에, Kafka 는 메시지 처리에 대해 안정적은 순서 보장을 제공한다. Kafka 는 동일한 토픽 파티션에 전송된 모든 메시지가 순서대로 처리됨을 보장한다.

파트 1을 떠올려보면, Kafka 는 메시지를 라운드 로빈 파티셔너를 사용하여 파티션에 메시지를 분산시킨다. 그러나, 생산자는 각각의 메시지에 파티션 키를 설정하여 데이터의 논리적 스트림을 생성할 수 있다. (예: 동일한 기기로 부터의 메시지 혹은 동일한 테넌트에 속하는 메시지)

같은 스트림의 모든 메시지는 같은 파티션 내에 위치하여 소비자 그룹에 의해 순서대로 처리되도록 한다.

그러나, 소비자 그룹 내의 각 파티션은 단일 소비자의 단일 스레드로 처리된다. 결과적으로, 단일 파티션의 처리를 확장할 수는 없다.

그러나, Kafka 에서는 토픽 내에 파티션의 수를 확장하여 각 파티션이 더 적은 메시지를 수신하고 추가적인 파티션에 대한 소비자를 추가할 수 있다.

#### 승자
Kafka 는 메시지를 순서대로 처리할 수 있는 명백한 승자이고, RabbitMQ 는 메시지 순서 보장이 약하다.

### 메시지 라우팅
![image](./images/router.jpg)

RabbitMq 는 구독자-정의 라우팅 규칙에 기반하여 메시지 교환의 구독자들에게 메시지를 라우팅할 수 있다. 토픽 교환은 routing_key 라고 부르는 전용 헤더에 기반하여 메시지를 라우팅할 수 있다.

대안으로, 헤더 교환은 임의의 메시지 헤더에 기반하여 메시지를 라우팅 할 수 있다. 두 교환은 효과적으로 소비자가 받고자하는 메시지의 유형을 명시할 수 있게 해주기 때문에, 솔루션 아키텍트에게 큰 유연성을 제공한다.

반면에 Kafka 는 소비자가 토픽의 메시지를 폴링하기전에 필터링할 수 없다. 구독한 소비자는 예외없이 파티션 내의 모든 메시지를 수신해야만 한다. 

개발자로서, 토픽으로 부터 메시지를 읽고, 필터링하고, 소비자가 구독 가능한 또 다른 토픽으로 집어 넣는 Kafka stream job 을 사용할 수 있다. 그럼에도 불구하고 이는 더 많은 노력과 유지보수가 필요하다.

#### 승자
RabbitMQ 는 소비자가 사용할 메시지를 라우팅 및 필터링 하는데 있어 탁월한 지원을 제공한다.


### 메시지 타이밍

![image](./images/message_timing.jpg)

RabbitMQ 는 메시지가 큐로 전송되는 타이밍에 관한 다양한 기능을 제공한다.

#### 메시지 생존시간 (TTL)
TTL 속성은 RabbitMQ 로 전송된 각 메시지와 연관지을 수 있다. TTL 설정은 생산자가 직접 혹은 큐 자체의 정책에 의해 완료될 수 있다.

TTL을 지정함으로써 시스템이 메시지의 유효한 기간을 제한하도록 할 수 있다. 소비자가 시간 내에 처리하지 않는 다면, 큐에서 자동적으로 제거된다. (dead-letter 교환으로 보내지지만, 나중에 더 많이 보내진다.)

TTL은 처리하지 않고 일정 시간이 지난 후에는 필요가 없어지는 시간에 민감한 명령에 대해 특히 유용하다.

#### 지연된/스케쥴된 메시지
RabbitMQ 는 플러그인을 사용하여 지연된/스케쥴된 메시지를 지원한다. 
메시지 교환에서 이 플러그인이 활성화 되어 있으면, 생산자는 RabbitMQ 로 메시지를 보낼 수 있고, RabbitMQ 가 해당 메시지를 소비자의 큐로 메시지를 라우팅하는 시간을 지연시킬 수 있다.

이 기능은 개발자가 향후 명령을 예약하여 그 이전에는 처리할 수 없도록 할 수 있다. 예를 들어, 생산자가 스로틀링 규칙에 도달하면 특정 명령의 실행을 나중으로 지연시킬 수도 있는 것이다.

Kafka 는 이러한 기능들을 지원하지 않는다. 메시지가 도착하는대로 파티션에 쓰고, 소비자는 즉시 해당 메시지를 소비할 수 있게 된다.

또한, Kafka 는 메시지에 대한 TTL 메커니즘을 제공하지 않지만 애플리케이션 레벨에서 구현할 수는 있다.

Kafka 파티션은 덧붙이기만 가능한 트랜잭션 로그라는 점을 기억해야 한다. 결과적으로, Kafka 는 메시지 타임(혹은 파티션 내 메시지 위치)에 대한 조작이 불가능 하다.

#### 승자
구현의 본질이 Kafka 를 제한하기 때문에, 이번에는 의심의 여지없이 RabbitMQ 의 승리다.


### 메시지 보존
![image](./images/message_retention.jpg)

RabbitMQ 는 소비자가 메시지를 성공적으로 소비하는 즉시 저장공간에서 메시지를 제거한다. 이 동작은 거의 모든 메시지 브로커 설계의 일부이기 때문에 변경이 불가능하다.

반대로, Kafka 는 토픽별로 설정한 타임아웃까지 모든 메시지를 유지한다. 메시지의 보존과 관련하여, Kafka 는 메시지 로그 역할을 하기 때문에 소비자의 소비 상태에 관해서는 신경쓰지 않는다.

소비자는 원하는만큼 모든 메시지를 소비할 수 있고, 파티션 오프셋을 수정함으로써 시간에 따라 앞, 뒤로 이동할 수 있다. 주기적으로 Kafka 는 토픽 내 메시지들의 age 를 검토하여 충분히 오래된 메시지는 제거한다.

Kafka 의 성능은 저장공간 크기에 의존하지 않는다. 그렇기 때문에 이론적으로는 성능에 영향없이 메시지를 거의 무한정 저장할 수 있다. (노드가 이 파티션들을 저장할만큼 충분히 커야 한다.)

#### 승자
Kafka 는 메시지를 보존하도록 설계되어 있는 반면, RabbitMQ 는 그렇지 않다. 여기선 경쟁할 거리도 없이 Kafka 의 승리다.